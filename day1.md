> GCC编译器
> 
> 写程序思路
> 
> 数据类型
> 
> 运算符和表达式
> 
> 输入、输出专题


# GCC编译器

```c
编译器gcc
C源文件——预处理——编译——汇编——链接——可执行文件
    
gcc -E hello.c -> hello.i
// hello.i为预处理后的文件
gcc -S hello.i
// 生成hello.s,为编译后的文件，hello.s其实是汇编语言文件
gcc -c hello.s
// 汇编生成hello.o，该文件已经无法用编辑器打开
gcc hello.o -o hello
// 链接生成可执行文件，文件名为hello

可以跳过上述这些步骤直接gcc hello.c, 默认生成a.out
    
或者 gcc hello.c -o hello
    
更懒惰一点：make hello
    
make会主动去目标文件名hello加上.c后缀的文件，即hello.c,若找到，则自动编译，找不到则报错
    
gcc hello.c -Wall 打印出所有的警告
```



# 写程序思路

```c
1. 头文件包含的重要性
	如果一个函数没有声明原型，那么默认返回值为int；
	类型： void * 是万金油类型，赋给任何类型的指针不需要强制转换。
	出现“段错误 （core dumped）”不要紧张，-Wall参数，将所有警告打印出来
2. 以函数为单位进行程序的编写
3. 声明部分+实现部分
	变量先定义，后使用
4. return 0;
	C语言中返回0一般表示正确执行
	返回值是给进程的父进程看的
	面试题：如果忘记写return 0,那么main函数的结束状态是什么？答案：最近一条语句的返回值。
	echo $? 打印上一个程序的状态
5. 多用空格空行
6. 添加注释
第1种注释：/* */
第2种注释：//
第3种注释：适用于大段注释，比如注释掉一个函数
#if 0
#endif
注：#if 0 表示不参与编译
        
算法：解决问题的方法（流程图、NS图、有限状态机FSM）

程序：用某种语言实现的算法

进程：运行中的程序，这一步起，开始占用系统资源

防止写越界，防止内存泄漏，谁打开谁关闭，谁申请谁释放
```

# 数据类型，运算符和表达式

## 1、数据类型

```c
数据类型（基本数据类型）
基本类型：数值类型（整型 short int long, 浮点类型 float double） 字符类型（char）
构造类型：数组 结构体 共用体 枚举类型
指针类型
空类型 void

注：C语言可以识别十进制、八进制和十六进制，唯独没有二进制表示
    
默认十进制，0开头的为八进制，0x开头为十六进制
    
整型数采用补码形式存储
```

```c
32位浮点数的存储结构：符号位（1位）+ 阶码（8位）+ 小数部分（23位）// 0.789*10^-3
符号数（ASCII码）：0号字符为Null 
标准C中ACSII码只有128个字符，扩展的ACSII有256个字符，后面增加的128个字符主要是图形符号
```

```c
数据类型的注意事项
1）所占字节数
2）存储区别
3）不同类型的数据间进行转换（隐式转换，显式转换（强制类型转换））
    float -> int //精度丢失 
	隐式转换向高精度靠拢	
    //float - double -->double
    //(char + int) - (float - double) -->int - double -->double
4）特殊性
	布尔类型,本质就是整型，true(非0) / false(0)，需要#include<stdbool.h>
	float类型并不是一个精确具体的数，无法将float类型与0判等，一般引入eps=1e-6
	char在标准C中没有明确是有符号还是无符号的，因此，要是明确数据的符号，应采用int，或者unsigned int
	不同的零值：0, '0', "0"， '\0', NULL
	 数据类型与后续代码中使用的输入输出要相匹配
```

## 2、变量与常量

```c
常量：在程序执行过程中值不会发生变化的量
    
分类：整型常量，实型常量，字符常量，字符串常量，标识常量
整型常量：1，798，76，52
实型常量：3.14，5.26，1.999
字符常量：由单引号引起来的单个字符或转义字符，如：'a', '\n', '\015'# '\ddd'八进制, '\xae'# '\xhh'十六进制
字符串常量：由双引号引起来的一个或多个字符组成的序列(空串，'\0',占一个字符)，如：""，"a"，"abXYZ", "abc\n\021\018"
//c语言中没有字符串类型。
    
标识常量：#define 定义的内容
#define 宏名 宏体
//#define	PI	3.14ab
预处理时，只是单纯的用宏体完整地替换宏名，不会检查语法。 宏体加()
宏也可以写成带参的形式
#define		MAX(a,b)	(a>b?a:b)
    
宏函数占用编译时间，并不占用运行时间，但宏使用比较危险，有很多技巧性，而普通函数占用运行时间。
#define,处理在程序的预处理阶段，不占用运行时间，占用编译时间，一改全改，缺点：不检查语法，只是单纯宏体与宏名之间的替换。
内核代码常常使用宏函数
注：数组名是典型的常量
```

```c
变量：用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量。
    
定义：[存储类型] 数据类型 标识符 = 值
	TYPE NAME = VALUE;
//标识符：由字母、数字、下划线组成且不能以数字开头的一个标识序列。
写标识符尽量做到见名知意。
数据类型：基本数据类型+构造类型；
	值和数据类型应注意匹配。
    
存储类型：auto static register extern(说明型关键字)//定义型
auto: 默认，自动分配空间，自动回收空间
    32位系统，可用的最大内存空间为4GB，但用户实际可用0～3GB，最高1GB留给操作系统内核，最开头一段用	户一般也无法使用，从程序起始地址开始分为：
    程序段，已用数据段，未用数据段，堆（动态内存分配的空间), 栈（不挨着堆，auto类型的变量在栈空间中）
register：（建议型）寄存器类型，相关限制：
	只能定义局部变量，不能定义全局变量；
	大小有限制，只能定义32位大小的类型数据，如double就不可以；
	寄存器没有地址，所以一个寄存器类型的变量无法打印出地址查看或使用。	
//register是建议编译器将变量放在寄存器空间中，但由于寄存器资源非常宝贵，编译器不一定这么做
static：静态类型，自动初始化为零值或空值，并且该类型的值//有继承性,相同地址；
	另外，常用于修饰一个变量或者函数，将变量和函数的作用域限制在本文件内，防止变量和函数扩张。
    //main.c	proj.c	proj.h
extern：说明型，意味着不能改变被说明的变量的类型和值。extern i; 也可以，但一定不能改变变量的类型和值，extern可扩展变量和函数的作用域。

变量的生命周期和作用范围
1）全局变量和局部变量
全局变量作用位置：从当前定义开始直至程序结束；
尽量不使用全局变量，全局变量副作用：可能导致值被修改，导致程序混乱。//局部变量内部屏蔽外部
GCC可以打印出当前函数名,以及显示当前行号
    printf("%s", __FUNCTION__);
    printf("%d", __LINE__);
为了避免重复申明，标准的.h文件格式：
    #ifndef _PROJ_H__
    #define _PROJ_H__
    内容......
    #endif
    
2）局部变量和局部变量
3）参考图片(存储类型比较)
测试案例中可能看不出效果，因为gcc进行了优化
```

## 3、运算符和表达式

```c
(1)表达式与语句的区别
表达式加上分号则为语句 
(2)运算符部分
1)每个运算符所需要的参与运算的操作数个数
2)结合性
3)优先级
4)运算符的特殊用法
    如：%两边操作数应都是整型;
    自增/自减 运算符在前，先进行计算，再取变量值使用，变量在前，先取变量值使用，再进行计算;
    逻辑&&和||运算存在短路特性
    = 和 == 的区别
5)位运算的重要意义
```

|     算术运算符      | + - * / % ++ -- |
| :-----------------: | :-------------: |
|     关系运算符      | < <= == > >= != |
|     逻辑运算符      |   ！ && \|\|    |
|      位运算符       | << >> ~ \| ^ &  |
| 赋值运算符及其扩展  |        =        |
|     条件运算符      |       ?:        |
|     逗号运算符      |        ,        |
|     指针运算符      |       * &       |
|      求字节数       |    sizeof()     |
| 强制类型转换 (类型) |                 |

```c
强制类型转换改变的是中间过程；
尽量不用强制转换。

位运算：用于直接操作硬件，二进制运算；	// >>	<<	~	| 	^(按位异或)	&	
将操作数中第n位置1，其他位不变： num = num | (1<<n);
将操作数中第n位清0，其他位不变： num = num & ~(1<<n);	//	取反
测试第n位：if(num & 1 << n)	//1为真	0为假
从一个指定宽度的数中取出其中的某几位
```

#  输入、输出专题

```c
input & output --> I/O （标准IO，文件IO）
```

## 1、格式化输入输出函数scanf，printf

```c
int printf(const char *format, ...)
    format:"%[修饰符]格式字符"
	// 标准输出格式字符
    d,u十进制		x十六进制		o八进制
    c字符		s字符串		f小数形式浮点数		e指数形式浮点数		g e和f中较短的一种		% 
	// 标准输出修饰符
        m-----------输出数据域宽，数据长度<m，左补空格；否则按实际输出	// %8d
        .n-----------对实数，指定小数点后位数（四舍五入）// %.4d					//m.n----%8.4d
        					 对字符串，制定实际输出位数		// %.4s
        -	-----------输出数据左对齐（缺省右对齐）
        +  -----------在有符号数的正数前显示正号（+）
        0 ------------输出数值时指定左面而不使用的空位置自动补0
        # ------------在八进制，十六进制数前显示0,0x	// %#x
        l -------------在d,o,x,u前指定输出精度为long型
        					   在e,f,g前指定输出精度为double型
        
        数据的类型声明一定要准确，60LL, 60L，输出时数据和标志符一定要一一对应	
        //LL单位	5G : 5LL*1024LL*1024LL*1024LL
        
如果宏定义的常值很大，可以加上后缀LL，更加保险
如果格式字符和后面的输出数据个数不匹配，gcc并不会报错，也不会给出警告，-Wall参数会给出相应警告
如果格式字符个数多于后面的输出数据，会顺着当前变量在压栈中的位置向上查找对应的字节数输出（变参函数实现）
变参函数 vs 重载
变参函数：多传参数，编译器不会报错
重载：如果多传参数，直接报错
// printf语句最好都加一个/n,因为当前是输出到终端，遇到/n会强制刷新缓冲区
	刷新缓冲：/n,或者缓冲区满，或者程序结束，或者遇到强制缓冲函数
	Linux环境下sleep()函数，以s单位
```

```C
int scanf(const char *format, 地址表);

scanf()		
	输入的东西一定要和输入表里的说明相匹配
	char str[STRSIZE]
scanf("%s%d", str1,&inti)	//成功后返回值为2,1个%为1
	输入参数是已经定义好的“字符数组名”, 不用加&, 因为在C语言中数组名就代表该数组的起始地址
	输入的东西不要出现间隔符 
	注意scanf中使用 %s 是非常危险的，越界了也不会报错，不知道存储空间大小。
scanf()直接放到循环体中不太妥当，需要加判断// 判断返回值
    对输入连用情况：
    	scanf("%d",&i);
		scanf("%c",&ch);	//第二个scanf获取值会异常，受间隔符，空格，回车，tab键等影响
	format中可以加入抑制符 *
	抑制符的使用可以帮助吃掉无用的间隔符，空格，回车，tab键等
        scanf("%d",&i);
        scanf("%*c%c", &ch)	//或中间加一个getchar
```

## 2、字符输入输出函数：getchar, putchar

```c
	int ch;
	
	ch = getchar();			//输入i
	putchar(ch);
	// i
```

## 3、字符串输入输出函数：gets(!), puts()

```c
gets();危险，越界可正常使用！！！！不常用。可用fgets(),getline.
```

